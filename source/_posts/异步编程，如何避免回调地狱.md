---
title: 异步编程，如何避免回调地狱
date: 2017-06-20 16:36:03
tags: [es6,es7,javascript,nodejs]
categories: 前端
id: 6
---
在js编程中，很容易遇到异步的情况。比如前端的发送ajax请求、定时器，后端nodejs的数据库读取，文件读取等。传统的异步编程方式，都是基于回调函数的。但由于回调函数嵌套过多，会造成代码复杂难以维护，且难以捕捉到代码异常，于是，新版本的ECMAScript针对这一情况有了改进。
<!-- more -->
**什么是回调地狱？**
```js
exports.findList=function (findObj,callback) {
    Info.find(findObj,function (err,info) {
        info.forEach((f, i) =>{
             f.image=f.images.split(',')[0];
             User.findById(f.author_id,function (error,user) {
                 f.author_name=user.name;
                 f.author_avatar=user.avatar;
                 if(i==info.length-1){
                     callback(err,info);
                 }
             })
        })
    })
}
```

这是我毕设中的一段node代码的原始版本。其中`Info.find`、`User.findById`等操作是异步的，执行时不会立马得到结果，在进行数据库操作的时候，js引擎不需要等待它，而是继续执行后面的代码。如果想要在它结束后进行某种操作，就必须把代码写在它的回调函数中。在回调函数中继续进行异步操作，执行回调，即为回调嵌套，如果涉及到多个回调嵌套，就陷入回调地狱了。


从上面代码可以看出，我们需要在所有`User.findById`执行完后，再执行`callback`，于是采用了计数的办法，当最后一个`User.findById`完成后，`callback`执行。但从某种意义上来看这种方法有些丑陋，代码的可读性不高。


**下面我将用以下几种方式对这段代码进行改造：**
* `Promise`
* `await/async`
* `Generator`

**改造开始↓↓↓↓↓↓**

1. ES6中的`Promise`对象
```js
exports.findList=function (findObj,callback) {
    Info.find(findObj,function (err,info) {
        const promises = info.map(f => new Promise((res,rej) =>{
            f.image=f.images.split(',')[0];
            User.findById(f.author_id,function (error,user) {
                if(error){
                    rej(error);
                    return;
                }
                f.author_name = user.name;
                f.author_avatar = user.avatar;
                res(f);
            })
        }));
        Promise.all(promises)
            .then(values =>{
                <!-- 成功的时候，这个 values 是所有 info 对象，
                作为一个数组返回出来，而不是某一个 -->
                callback(null, values);
            })
            .catch(error =>{
                <!-- 注意这里 error 是第一个失败 error，不是所有的 error  -->
                callback(error);
            })
    }
}
```
    代码将所有的`User.findById`都加入了一个数组，数组的每一项都是一个`Promise`实例，然后用`Promise.all().then()`，当数组中所有的`Promise`实例完成后，`then()`中的函数才执行。
    
2. ES7中的`await/async`
```js
exports.findList=function (findObj,callback) {
    Info.find(findObj,function (err,info) {
        const promises = info.map(f => new Promise((res,rej) =>{
            f.image=f.images.split(',')[0];
            User.findById(f.author_id,function (error,user) {
                if(error){
                    rej(error);
                    return;
                }
                f.author_name = user.name;
                f.author_avatar = user.avatar;
                res(f);
            })
        }));
        (async ()=>{
            try{
                const values = await Promise.all(promises);
                <!-- await 后面是一个 promise 对象，但不用写 then， 
                其返回值 values 即为传入 res 的参数。-->
                callback(null, values);
            } catch (error){
                callback(error);
            }
        })()
    }
}
```
    wait